"""
Export Engine - Generate downloadable reports from analysis results

Supports:
- Markdown export (with Mermaid diagrams)
- HTML export (rendered, standalone)
- JSON export (raw data)
- PDF export (via HTML rendering)
"""

import json
import logging
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any
from io import BytesIO

from app.core.akg import ArchitecturalKnowledgeGraph

logger = logging.getLogger(__name__)


@dataclass
class ExportOptions:
    """Options for export generation."""
    include_diagrams: bool = True
    include_evidence: bool = True
    include_akg_details: bool = False
    include_raw_data: bool = False
    audience: str = "engineer"
    title: Optional[str] = None


class ExportEngine:
    """
    Generates exportable reports from analysis results.
    
    Supports multiple formats:
    - Markdown (.md) - With embedded Mermaid diagrams
    - HTML (.html) - Standalone rendered document
    - JSON (.json) - Raw structured data
    """
    
    def __init__(self):
        pass
    
    def export_markdown(
        self,
        analysis_result: Dict[str, Any],
        options: Optional[ExportOptions] = None
    ) -> str:
        """
        Export analysis results as Markdown.
        
        Args:
            analysis_result: Complete analysis result dict
            options: Export options
            
        Returns:
            Markdown string
        """
        options = options or ExportOptions()
        
        lines = []
        
        # Header
        repo_url = analysis_result.get("repo_url", "Repository")
        repo_name = repo_url.split("/")[-1].replace(".git", "") if "/" in repo_url else repo_url
        title = options.title or f"Architecture Analysis: {repo_name}"
        
        lines.append(f"# {title}")
        lines.append("")
        lines.append(f"> Generated by RepoBlueprint AI on {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        lines.append("")
        
        # Metadata
        lines.append("## Overview")
        lines.append("")
        lines.append(f"- **Repository**: {repo_url}")
        if analysis_result.get("branch"):
            lines.append(f"- **Branch**: {analysis_result.get('branch')}")
        lines.append(f"- **Audience**: {analysis_result.get('audience', 'Engineer')}")
        lines.append("")
        
        # Architecture section
        arch = analysis_result.get("architecture", {})
        if arch:
            lines.append("## Architecture")
            lines.append("")
            
            if arch.get("architecture_style"):
                lines.append(f"**Style**: {arch.get('architecture_style')}")
                lines.append("")
            
            # Bounded Contexts
            contexts = arch.get("bounded_contexts", [])
            if contexts:
                lines.append("### Bounded Contexts")
                lines.append("")
                for ctx in contexts:
                    name = ctx.get("name", "Unknown")
                    purpose = ctx.get("purpose", ctx.get("description", ""))
                    lines.append(f"#### {name}")
                    if purpose:
                        lines.append(f"{purpose}")
                    entities = ctx.get("key_entities", [])
                    if entities:
                        lines.append(f"\n**Key Entities**: {', '.join(entities[:10])}")
                    lines.append("")
            
            # Design Patterns
            patterns = arch.get("key_design_patterns", [])
            if patterns:
                lines.append("### Design Patterns")
                lines.append("")
                for pattern in patterns:
                    if isinstance(pattern, dict):
                        lines.append(f"- **{pattern.get('pattern', 'Unknown')}**: {pattern.get('description', '')}")
                    else:
                        lines.append(f"- {pattern}")
                lines.append("")
            
            # Coupling/Cohesion
            coupling = arch.get("coupling_cohesion_assessment", {})
            if coupling:
                lines.append("### Quality Metrics")
                lines.append("")
                lines.append(f"| Metric | Score |")
                lines.append(f"|--------|-------|")
                lines.append(f"| Coupling | {coupling.get('coupling_score', 'N/A')}/10 |")
                lines.append(f"| Cohesion | {coupling.get('cohesion_score', 'N/A')}/10 |")
                lines.append("")
        
        # Diagrams
        diagrams = analysis_result.get("diagrams", {})
        if options.include_diagrams and diagrams:
            lines.append("## Diagrams")
            lines.append("")
            
            for diagram_name, diagram_code in diagrams.items():
                if diagram_code:
                    readable_name = diagram_name.replace("_", " ").title()
                    lines.append(f"### {readable_name}")
                    lines.append("")
                    lines.append("```mermaid")
                    lines.append(diagram_code)
                    lines.append("```")
                    lines.append("")
        
        # Documentation
        docs = analysis_result.get("documentation", {})
        if docs:
            lines.append("## Documentation")
            lines.append("")
            
            # Executive Summary
            if docs.get("executive_summary"):
                lines.append("### Executive Summary")
                lines.append("")
                lines.append(docs.get("executive_summary"))
                lines.append("")
            
            # Key Findings
            findings = docs.get("key_findings", [])
            if findings:
                lines.append("### Key Findings")
                lines.append("")
                for finding in findings:
                    if isinstance(finding, dict):
                        importance = finding.get("importance", "Medium")
                        icon = "üî¥" if importance == "High" else "üü°" if importance == "Medium" else "üü¢"
                        lines.append(f"- {icon} {finding.get('finding', '')}")
                    else:
                        lines.append(f"- {finding}")
                lines.append("")
            
            # Recommendations
            recs = docs.get("recommendations", [])
            if recs:
                lines.append("### Recommendations")
                lines.append("")
                for rec in recs:
                    if isinstance(rec, dict):
                        priority = rec.get("priority", "Medium")
                        lines.append(f"- **[{priority}]** {rec.get('recommendation', '')}")
                    else:
                        lines.append(f"- {rec}")
                lines.append("")
            
            # ADRs
            adrs = docs.get("generated_adrs", [])
            if adrs:
                lines.append("### Architecture Decision Records")
                lines.append("")
                for adr in adrs:
                    if isinstance(adr, dict):
                        lines.append(f"#### {adr.get('title', 'ADR')}")
                        lines.append(f"**Status**: {adr.get('status', 'Proposed')}")
                        lines.append("")
                        if adr.get("context"):
                            lines.append(f"**Context**: {adr.get('context')}")
                            lines.append("")
                        if adr.get("decision"):
                            lines.append(f"**Decision**: {adr.get('decision')}")
                            lines.append("")
                        if adr.get("consequences"):
                            lines.append(f"**Consequences**: {adr.get('consequences')}")
                            lines.append("")
                lines.append("")
        
        # Evidence Map
        if options.include_evidence:
            evidence = arch.get("evidence_map", {})
            if evidence:
                lines.append("## Evidence Map")
                lines.append("")
                lines.append("| Claim | File | Lines | Confidence |")
                lines.append("|-------|------|-------|------------|")
                
                for claim_id, ev in list(evidence.items())[:20]:
                    if isinstance(ev, dict):
                        file_path = ev.get("file_path", "")
                        line_range = ev.get("line_range", "")
                        confidence = ev.get("confidence", "medium")
                        lines.append(f"| {claim_id} | `{file_path}` | {line_range} | {confidence} |")
                
                lines.append("")
        
        # Stats
        stats = analysis_result.get("stats", {})
        if stats:
            lines.append("## Statistics")
            lines.append("")
            lines.append(f"- **Total Files**: {stats.get('total_files', 'N/A')}")
            lines.append(f"- **Critical Files**: {stats.get('critical_files', 'N/A')}")
            lines.append(f"- **Parsed Files**: {stats.get('parsed_files', 'N/A')}")
            lines.append("")
        
        # Footer
        lines.append("---")
        lines.append("*Generated by [RepoBlueprint AI](https://github.com/repoblueprintai)*")
        
        return "\n".join(lines)
    
    def export_html(
        self,
        analysis_result: Dict[str, Any],
        options: Optional[ExportOptions] = None
    ) -> str:
        """
        Export analysis results as standalone HTML.
        
        Includes embedded CSS and Mermaid.js for diagram rendering.
        """
        markdown = self.export_markdown(analysis_result, options)
        
        # Convert to HTML with embedded styles and Mermaid
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Architecture Analysis Report</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {{
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --border: #334155;
        }}
        
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }}
        
        h1 {{ 
            font-size: 2rem; 
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }}
        
        h2 {{ 
            font-size: 1.5rem; 
            margin: 2rem 0 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }}
        
        h3 {{ 
            font-size: 1.25rem; 
            margin: 1.5rem 0 0.75rem;
            color: var(--accent);
        }}
        
        h4 {{ 
            font-size: 1rem; 
            margin: 1rem 0 0.5rem;
        }}
        
        p {{ margin: 0.75rem 0; }}
        
        blockquote {{
            border-left: 3px solid var(--accent);
            padding-left: 1rem;
            color: var(--text-secondary);
            font-style: italic;
        }}
        
        ul, ol {{ 
            margin: 0.75rem 0; 
            padding-left: 1.5rem;
        }}
        
        li {{ margin: 0.25rem 0; }}
        
        code {{
            background: var(--bg-secondary);
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }}
        
        pre {{
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }}
        
        pre code {{
            background: none;
            padding: 0;
        }}
        
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }}
        
        th, td {{
            border: 1px solid var(--border);
            padding: 0.5rem;
            text-align: left;
        }}
        
        th {{
            background: var(--bg-secondary);
        }}
        
        .mermaid {{
            background: #1e1e2e;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
        }}
        
        hr {{
            border: none;
            border-top: 1px solid var(--border);
            margin: 2rem 0;
        }}
        
        @media print {{
            body {{ background: white; color: black; }}
            .mermaid {{ background: white; }}
        }}
    </style>
</head>
<body>
    <div id="content"></div>
    
    <script>
        mermaid.initialize({{ startOnLoad: false, theme: 'dark' }});
        
        const markdown = {json.dumps(markdown)};
        
        // Custom renderer for mermaid
        const renderer = new marked.Renderer();
        renderer.code = function(code, language) {{
            if (language === 'mermaid') {{
                return '<div class="mermaid">' + code + '</div>';
            }}
            return '<pre><code>' + code + '</code></pre>';
        }};
        
        marked.setOptions({{ renderer: renderer }});
        
        document.getElementById('content').innerHTML = marked.parse(markdown);
        
        // Render mermaid diagrams
        mermaid.run({{ querySelector: '.mermaid' }});
    </script>
</body>
</html>"""
        
        return html
    
    def export_json(
        self,
        analysis_result: Dict[str, Any],
        options: Optional[ExportOptions] = None
    ) -> str:
        """Export analysis results as JSON."""
        options = options or ExportOptions()
        
        # Filter based on options
        export_data = {
            "meta": {
                "exported_at": datetime.now().isoformat(),
                "version": "3.0",
            },
            "repo_url": analysis_result.get("repo_url"),
            "branch": analysis_result.get("branch"),
            "audience": analysis_result.get("audience"),
        }
        
        if analysis_result.get("architecture"):
            export_data["architecture"] = analysis_result["architecture"]
        
        if analysis_result.get("documentation"):
            export_data["documentation"] = analysis_result["documentation"]
        
        if options.include_diagrams and analysis_result.get("diagrams"):
            export_data["diagrams"] = analysis_result["diagrams"]
        
        if options.include_akg_details and analysis_result.get("akg"):
            export_data["akg"] = analysis_result["akg"]
        
        export_data["stats"] = analysis_result.get("stats", {})
        
        return json.dumps(export_data, indent=2, default=str)
    
    def export_diff_markdown(
        self,
        diff_result: Dict[str, Any],
        options: Optional[ExportOptions] = None
    ) -> str:
        """
        Export diff results as Markdown.
        """
        lines = []
        
        lines.append(f"# Architecture Diff Report")
        lines.append("")
        lines.append(f"> {diff_result.get('base_ref', 'base')} ‚Üí {diff_result.get('target_ref', 'target')}")
        lines.append("")
        
        # Summary
        lines.append("## Summary")
        lines.append("")
        lines.append(diff_result.get("summary", "No summary available"))
        lines.append("")
        
        # Risk
        risk = diff_result.get("risk_level", "low")
        risk_emoji = {"low": "üü¢", "medium": "üü°", "high": "üü†", "critical": "üî¥"}.get(risk, "‚ö™")
        lines.append(f"**Risk Level**: {risk_emoji} {risk.title()}")
        lines.append("")
        
        # Stats
        stats = diff_result.get("stats", {})
        if stats:
            lines.append("## Changes")
            lines.append("")
            lines.append(f"| Metric | Count |")
            lines.append(f"|--------|-------|")
            lines.append(f"| Added | +{stats.get('added', 0)} |")
            lines.append(f"| Removed | -{stats.get('removed', 0)} |")
            lines.append(f"| Modified | ~{stats.get('modified', 0)} |")
            lines.append(f"| **Total** | **{stats.get('total_changes', 0)}** |")
            lines.append("")
        
        # Breaking Changes
        breaking = diff_result.get("breaking_changes", [])
        if breaking:
            lines.append("## ‚ö†Ô∏è Breaking Changes")
            lines.append("")
            for change in breaking:
                lines.append(f"- {change}")
            lines.append("")
        
        # Node Changes
        node_changes = diff_result.get("node_changes", [])
        if node_changes:
            lines.append("## Component Changes")
            lines.append("")
            
            added = [c for c in node_changes if c.get("change_type") == "added"]
            removed = [c for c in node_changes if c.get("change_type") == "removed"]
            modified = [c for c in node_changes if c.get("change_type") == "modified"]
            
            if added:
                lines.append("### Added")
                for c in added[:20]:
                    lines.append(f"- ‚úÖ **{c.get('node_name')}** ({c.get('node_type')})")
                lines.append("")
            
            if removed:
                lines.append("### Removed")
                for c in removed[:20]:
                    lines.append(f"- ‚ùå **{c.get('node_name')}** ({c.get('node_type')})")
                lines.append("")
            
            if modified:
                lines.append("### Modified")
                for c in modified[:20]:
                    lines.append(f"- üìù **{c.get('node_name')}**: {c.get('details', 'changed')}")
                lines.append("")
        
        lines.append("---")
        lines.append("*Generated by RepoBlueprint AI*")
        
        return "\n".join(lines)
